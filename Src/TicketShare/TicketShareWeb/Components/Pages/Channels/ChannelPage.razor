@page "/Channel/{ChannelId}"
@attribute [Authorize]

@using Microsoft.AspNetCore.Authorization
@using TicketShare.sdk
@using Toolbox.Graph.Extensions

<LoadingBlock Visible=@Visible />

<FeedColumn>
    <DialogControls OnClose="OnClose" />

    @foreach (var item in _messageList)
    {
        <ChannelMessageBlock Content=item />
    }

    <TextEditorBlock YesText="Send" OnYes="SendMessage" />

</FeedColumn>

@code {
    [Parameter] public string ChannelId { get; set; } = null!;
    [Inject] public AuthenticationAccess _authenticationAccess { get; set; } = null!;
    [Inject] public AppNavigation _appNavigation { get; set; } = null!;
    [Inject] public ChannelClient _channelClient { get; set; } = null!;
    [Inject] public ILogger<ChannelPage> _logger { get; set; } = null!;

    private ChannelContext _channelContext;
    private bool Visible { get; set; } = true;
    private IReadOnlyList<ChannelMessage> _messageList = [];
    private string _principalId = null!;

    protected override async Task OnParametersSetAsync()
    {
        _principalId = (await _authenticationAccess.GetPrincipalId()).NotEmpty();
        _channelContext = _channelClient.GetContext(ChannelId, _principalId);

        await Refresh();
        Visible = false;
    }

    private void OnClose() => _appNavigation.GotoChannels();

    private async Task SendMessage(string message)
    {
        var channelMessage = new ChannelMessage
        { 
            ChannelId = ChannelId, 
            FromPrincipalId = _principalId, 
            Message = message 
        };

        var result = await _channelContext.AddMessage(channelMessage, new ScopeContext(_logger));
        if (result.IsError())
        {
            _logger.LogError("Failed to send message to channelId={channelId}", ChannelId);
            return;
        }
        await Refresh();
    }

    private async Task Refresh()
    {
        var listOption = await _channelContext.GetMessages(new ScopeContext(_logger));
        _messageList = listOption.IsOk() switch
        {
            true => listOption.Return(),
            false => [],
        };
    }
}
