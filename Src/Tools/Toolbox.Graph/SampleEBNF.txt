select (key=user:s1-user1) -> [seasonTicket-identity-to-identity] -> (*);

number              = regex: '[+-]?[0-9]+' ;
symbol              = regex: '[a-zA-Z][a-zA-Z0-9\-/]*' ;
base64              = regex: '[a-zA-Z][a-zA-Z0-9\-/]*' ;
equal               = '=' ;
join-left           = '->' ;
join-inner          = '<->' ;
node-sym            = 'node' ;
edge-sym            = 'edge' ;
return-sym          = 'return' ;
select-sym          = 'select' ;
delete-sym          = 'delete' ;
update-sym          = 'update' ;
upsert-syn          = 'upsert' ;
add-sym             = 'add' ;
set-sym             = 'set' ;
open-param          = '(' ;
close-param         = ')' ;
open-bracket        = '[' ;
close-bracket       = ']' ;
open-brace          = '{' ;
close-brace         = '}' ;
comma               = ',' ;
term                = ';' ;

alias               = symbol ;
tag                 = symbol, ['=', symbol ] ;
tags                = { comma, tag } ;
node-spec           = open-param, tag, { comma, tag }, close-param, [ symbol ] ;
edge-spec           = open-bracket, tag, { comma, tag }, close-bracket, [ symbol ] ;
join                = [ join-left | join-inner ] ;
return-query        = return-sym, symbol, { comma, symbol } ;
entity-data         = symbol, open-brace, base64, close-brace ;
set-cmd             = set-sym, tag, { comma, tag }

select-node-query   = node-spec, { join, edge-spec } ;
edge-node-query     = edge-spec, { join, node-spec } ;

addCommand          = add-sym, ( node-sym | edge-sym ), { comma, tag }, [ entity-data ], term ;
updateCommand       = update-sym, ( node-sym | edge-sym ), ( select-node-query | edge-node-query ), set-cmd, term;
deleteCommand       = delete-sym, ( node-sym | edge-sym ), ( select-node-query | edge-node-query ), term;
selectCommand       = select-sym, ( node-sym | edge-sym ), ( select-node-query | edge-node-query ), [ returnQuery ], term ;

alphaNumeric = 
open-param = (
close-param = )
nodeKey = 


// select node (key=k1) a1 -> [name] <-> (*) return name, name
// select [key='string value'];
// select [key='string value'] a1;
// select (key=key1,tags=t1) -> [schedulework:active];
// select (*) -> [*];
// select (key='string value') a1;
// select (key=key1,tags=t1) -> [schedulework:active]->(schedule) n2;
// select (t1) n1 -> [tags=schedulework:active]n3 -> (t2) n2 return entity, contract;
// select (*) -> [*] -> (*);

// update (*) set t1, t2;
// update (*) set t1 = v;
// update (*) set entity { abc };
// update (*) set entity { abc }, t1=v,t2=v2;
// update [FromKey=fKey] -> (key=key1) set key=key2,tags=t2;
// update [edgeType=abc*, schedulework:active] set fromKey=key1,toKey=key2,edgeType=et,tags=t2;
// update (key=key1) set key=key2,tags=t2;

// upsert edge fromKey=key1,toKey=key2,edgeType=et,tags=t2;
// upsert unique edge fromKey=key1,toKey=key2,edgeType=et,tags=t2;

// add edge fromKey=key1,toKey=key2,edgeType=et,tags=t2;
// add edge fromKey=key1,toKey=key2, t1 = v;
// upsert edge fromKey=key1,toKey=key2, t1;

// delete (*);
// delete (key='string value');
// delete (key='string value') a1;
// delete (key=key1,tags=t1) -> [schedulework:active];
// delete (key=key1,tags=t1) -> [schedulework:active]->(schedule) n2;

// upsert node key=key1, tags=t1;
// upsert node key=node1, entity { abc };

// add node key=node1, entity { abc };
// add node key=node1, entity { abc }, contract { ckey2 };
// add node key=node1, t1 = v,t2, entity { abc }, t3=a/b/c ;
